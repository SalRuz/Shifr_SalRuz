<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Doom Lab ‚Äî Ultimate Edition</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #ff0000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            max-width: 100%;
            max-height: 100%;
            overflow: hidden;
        }
        
        #game-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        
        #ui {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
            color: #fff;
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
            z-index: 10;
        }
        
        #weapon {
            width: 300px;
            height: 180px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="300" height="180" viewBox="0 0 300 180"><path d="M150,180 L140,120 L160,120 Z" fill="%23333"/><rect x="130" y="80" width="40" height="40" fill="%23555"/><rect x="135" y="85" width="30" height="30" fill="%23777"/></svg>') no-repeat center bottom;
            image-rendering: pixelated;
            cursor: crosshair;
            transform-origin: center bottom;
            transition: transform 0.05s ease-out;
        }
        
        .weapon-recoil {
            animation: recoil 0.3s ease-out;
        }
        
        @keyframes recoil {
            0% { transform: translateY(0) rotate(0deg); }
            20% { transform: translateY(15px) rotate(5deg); }
            100% { transform: translateY(0) rotate(0deg); }
        }

        #hud {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 80px;
            padding: 5px 0;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #ff0000;
            font-size: 14px;
            z-index: 10;
        }
        
        #map {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0000;
            z-index: 5;
        }

        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            z-index: 20;
        }

        .mobile-controls button {
            background: rgba(255,0,0,0.5);
            border: 2px solid #ff0000;
            color: white;
            font-size: 24px;
            width: 60px;
            height: 60px;
            margin: 5px;
            border-radius: 10px;
            touch-action: manipulation;
        }

        .dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
            position: absolute;
            left: 20px;
            bottom: 20px;
        }

        .dpad button:nth-child(5) { grid-column: 2; grid-row: 2; } /* S */
        .dpad button:nth-child(2) { grid-column: 2; grid-row: 1; } /* W */
        .dpad button:nth-child(4) { grid-column: 1; grid-row: 2; } /* A */
        .dpad button:nth-child(6) { grid-column: 3; grid-row: 2; } /* D */

        .turn-controls {
            position: absolute;
            right: 20px;
            bottom: 20px;
            display: flex;
            gap: 10px;
        }

        @media (max-width: 850px) {
            .mobile-controls { display: block; }
            #instructions { font-size: 12px; padding: 8px; }
        }

        #victory-screen, #game-over-screen, #settings-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: #ff0000;
            font-size: 36px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #victory-screen h2, #game-over-screen h2 {
            font-size: 48px;
            margin: 0 0 20px;
        }

        #victory-screen button, #game-over-screen button, #settings-screen button {
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 24px;
            background: #ff0000;
            color: white;
            border: none;
            cursor: pointer;
            margin: 10px;
        }

        .records, .settings-panel {
            margin: 20px 0;
            font-size: 20px;
            max-width: 600px;
        }

        .level-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 5px 15px;
            border: 2px solid #f00;
            font-size: 20px;
            z-index: 15;
        }

        .pickup-effect, .score-effect {
            position: absolute;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: float-up 1s ease-out forwards;
            z-index: 100;
        }

        .pickup-effect {
            color: #0f0;
        }

        .score-effect {
            color: #ff0;
        }

        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }

        .particle {
            position: absolute;
            pointer-events: none;
            z-index: 50;
            background: #f00;
            border-radius: 50%;
            width: 4px;
            height: 4px;
            opacity: 1;
        }

        #settings-toggle {
            position: absolute;
            top: 10px;
            right: 170px;
            background: rgba(0,0,0,0.7);
            color: #fff;
            border: 2px solid #f00;
            padding: 5px 10px;
            cursor: pointer;
            z-index: 20;
        }

        .settings-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            width: 80%;
            max-width: 500px;
        }

        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .setting-row label {
            min-width: 150px;
        }

        .setting-row input {
            width: 150px;
        }

        #fov-display {
            color: #0f0;
            font-weight: bold;
            margin-left: 10px;
        }

        .screen-vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(ellipse at center, transparent 50%, rgba(0,0,0,0.8) 100%);
            pointer-events: none;
            z-index: 1;
        }

        .enemy-sprite {
            position: absolute;
            width: 32px;
            height: 32px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 32 32"><rect x="8" y="4" width="16" height="24" fill="%23f00"/><circle cx="16" cy="10" r="6" fill="%23000"/><rect x="12" y="20" width="8" height="4" fill="%23000"/></svg>') no-repeat center;
            image-rendering: pixelated;
            transform: translate(-50%, -50%);
            z-index: 3;
        }

        .torch-light {
            position: absolute;
            width: 100px;
            height: 100px;
            background: radial-gradient(circle, rgba(255,100,0,0.3) 0%, transparent 70%);
            border-radius: 50%;
            pointer-events: none;
            z-index: 2;
            opacity: 0.7;
            animation: flicker 0.1s infinite alternate;
        }

        @keyframes flicker {
            0% { opacity: 0.6; transform: scale(0.95); }
            100% { opacity: 0.8; transform: scale(1.05); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <div class="screen-vignette"></div>
        <canvas id="game-canvas"></canvas>
        
        <div class="level-indicator">–£—Ä–æ–≤–µ–Ω—å: <span id="level-counter">1</span> | –û—á–∫–∏: <span id="score">0</span> | –£—Ä–æ–≤–µ–Ω—å –æ—Ä—É–∂–∏—è: <span id="weapon-level">1</span></div>
        
        <div id="ui">
            <div id="hud">
                <div>–ó–¥–æ—Ä–æ–≤—å–µ: <span id="health">100</span></div>
                <div>–ü–∞—Ç—Ä–æ–Ω—ã: <span id="ammo">50</span></div>
                <div>–í—Ä–µ–º—è: <span id="timer">00:00</span></div>
                <div>–®–∞–≥–æ–≤: <span id="steps">0</span></div>
            </div>
            <div id="weapon"></div>
        </div>
        
        <div id="instructions">
            <p>WASD ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ | ‚Üê ‚Üí ‚Äî –ø–æ–≤–æ—Ä–æ—Ç</p>
            <p>–ü—Ä–æ–±–µ–ª –∏–ª–∏ –∫–ª–∏–∫ ‚Äî –≤—ã—Å—Ç—Ä–µ–ª</p>
            <p>M ‚Äî –∫–∞—Ä—Ç–∞ | R ‚Äî –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —É—Ä–æ–≤–Ω—è</p>
            <p>O ‚Äî –Ω–∞—Å—Ç—Ä–æ–π–∫–∏</p>
        </div>
        
        <canvas id="map"></canvas>

        <button id="settings-toggle">‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏</button>

        <div class="mobile-controls">
            <div class="dpad">
                <button id="btn-w">W</button>
                <button id="btn-a">A</button>
                <button id="btn-s">S</button>
                <button id="btn-d">D</button>
            </div>
            <div class="turn-controls">
                <button id="btn-left">‚Üê</button>
                <button id="btn-right">‚Üí</button>
                <button id="btn-fire">üî´</button>
            </div>
        </div>

        <div id="victory-screen">
            <h2>–ü–û–ë–ï–î–ê!</h2>
            <div>–í—ã –ø—Ä–æ—à–ª–∏ —É—Ä–æ–≤–µ–Ω—å <span id="completed-level">1</span>!</div>
            <div>–û—á–∫–∏ –∑–∞ —É—Ä–æ–≤–µ–Ω—å: <span id="level-score">0</span></div>
            <div>–í—Å–µ–≥–æ –æ—á–∫–æ–≤: <span id="total-score">0</span></div>
            <div>–í—Ä–µ–º—è: <span id="final-time">00:00</span></div>
            <div>–®–∞–≥–æ–≤: <span id="final-steps">0</span></div>
            <div class="records" id="best-records"></div>
            <div>
                <button id="next-level-btn">–°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</button>
                <button id="restart-game-btn">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
            </div>
        </div>

        <div id="game-over-screen">
            <h2>–í–´ –ü–û–ì–ò–ë–õ–ò</h2>
            <div>–í—Ä–∞–≥–∏ –æ–∫–∞–∑–∞–ª–∏—Å—å —Å–∏–ª—å–Ω–µ–µ...</div>
            <div>–í—Å–µ–≥–æ –æ—á–∫–æ–≤: <span id="death-score">0</span></div>
            <div>–í—Ä–µ–º—è: <span id="death-time">00:00</span></div>
            <div>–®–∞–≥–æ–≤: <span id="death-steps">0</span></div>
            <button id="retry-btn">–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>

        <div id="settings-screen">
            <h2>–ù–ê–°–¢–†–û–ô–ö–ò</h2>
            <div class="settings-panel">
                <div class="setting-row">
                    <label for="volume-slider">–ì—Ä–æ–º–∫–æ—Å—Ç—å –∑–≤—É–∫–∞:</label>
                    <input type="range" id="volume-slider" min="0" max="1" step="0.1" value="0.5">
                    <span id="volume-display">50%</span>
                </div>
                <div class="setting-row">
                    <label for="fov-slider">–£–≥–æ–ª –æ–±–∑–æ—Ä–∞:</label>
                    <input type="range" id="fov-slider" min="45" max="120" step="5" value="60">
                    <span id="fov-display">60¬∞</span>
                </div>
                <div class="setting-row">
                    <label>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏–µ–º:</label>
                    <select id="move-key-w">
                        <option value="w">W</option>
                        <option value="i">I</option>
                        <option value="ArrowUp">‚Üë</option>
                    </select>
                    <select id="move-key-s">
                        <option value="s">S</option>
                        <option value="k">K</option>
                        <option value="ArrowDown">‚Üì</option>
                    </select>
                </div>
                <div class="setting-row">
                    <label>–£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –ø–æ–≤–æ—Ä–æ—Ç–æ–º:</label>
                    <select id="turn-key-left">
                        <option value="ArrowLeft">‚Üê</option>
                        <option value="a">A</option>
                        <option value="q">Q</option>
                    </select>
                    <select id="turn-key-right">
                        <option value="ArrowRight">‚Üí</option>
                        <option value="d">D</option>
                        <option value="e">E</option>
                    </select>
                </div>
            </div>
            <button id="save-settings-btn">–°–æ—Ö—Ä–∞–Ω–∏—Ç—å</button>
            <button id="close-settings-btn">–ó–∞–∫—Ä—ã—Ç—å</button>
        </div>
    </div>

    <script>
        // ======================
        // –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
        // ======================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const mapCanvas = document.getElementById('map');
        const mapCtx = mapCanvas.getContext('2d');
        const weaponEl = document.getElementById('weapon');
        const healthEl = document.getElementById('health');
        const ammoEl = document.getElementById('ammo');
        const timerEl = document.getElementById('timer');
        const stepsEl = document.getElementById('steps');
        const levelCounterEl = document.getElementById('level-counter');
        const scoreEl = document.getElementById('score');
        const weaponLevelEl = document.getElementById('weapon-level');
        const victoryScreen = document.getElementById('victory-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const settingsScreen = document.getElementById('settings-screen');
        const finalTimeEl = document.getElementById('final-time');
        const finalStepsEl = document.getElementById('final-steps');
        const deathTimeEl = document.getElementById('death-time');
        const deathStepsEl = document.getElementById('death-steps');
        const completedLevelEl = document.getElementById('completed-level');
        const bestRecordsEl = document.getElementById('best-records');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const retryBtn = document.getElementById('retry-btn');
        const settingsToggle = document.getElementById('settings-toggle');
        const saveSettingsBtn = document.getElementById('save-settings-btn');
        const closeSettingsBtn = document.getElementById('close-settings-btn');
        const volumeSlider = document.getElementById('volume-slider');
        const volumeDisplay = document.getElementById('volume-display');
        const fovSlider = document.getElementById('fov-slider');
        const fovDisplay = document.getElementById('fov-display');
        const moveKeyW = document.getElementById('move-key-w');
        const moveKeyS = document.getElementById('move-key-s');
        const turnKeyLeft = document.getElementById('turn-key-left');
        const turnKeyRight = document.getElementById('turn-key-right');

        canvas.width = 800;
        canvas.height = 600;
        mapCanvas.width = 150;
        mapCanvas.height = 150;

        const mapSize = 16;
        const tileSize = 64;

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–∑ localStorage –∏–ª–∏ –ø–æ —É–º–æ–ª—á–∞–Ω–∏—é
        let settings = JSON.parse(localStorage.getItem('doomLabSettings')) || {
            volume: 0.5,
            fov: 60,
            moveKeys: { w: 'w', s: 's' },
            turnKeys: { left: 'ArrowLeft', right: 'ArrowRight' }
        };

        // –ü—Ä–∏–º–µ–Ω—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        volumeSlider.value = settings.volume;
        volumeDisplay.textContent = Math.round(settings.volume * 100) + '%';
        fovSlider.value = settings.fov;
        fovDisplay.textContent = settings.fov + '¬∞';
        moveKeyW.value = settings.moveKeys.w;
        moveKeyS.value = settings.moveKeys.s;
        turnKeyLeft.value = settings.turnKeys.left;
        turnKeyRight.value = settings.turnKeys.right;

        // –¢—Ä–∏ —É—Ä–æ–≤–Ω—è
        const levels = [
            // –£—Ä–æ–≤–µ–Ω—å 1
            {
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1.5, y: 1.5 },
                enemies: [
                    { x: 4.5, y: 4.5, patrolPoints: [{x:4.5,y:4.5}, {x:8.5,y:4.5}], speed: 0.8, health: 30, damage: 10, state: 'patrol', currentIndex: 0, spriteFrame: 0 },
                    { x: 12.5, y: 10.5, patrolPoints: [{x:12.5,y:10.5}, {x:12.5,y:6.5}], speed: 1, health: 30, damage: 10, state: 'patrol', currentIndex: 0, spriteFrame: 0 }
                ],
                pickups: [
                    { type: 'health', x: 3.5, y: 3.5, amount: 25 },
                    { type: 'ammo', x: 10.5, y: 3.5, amount: 20 }
                ],
                torches: [
                    { x: 3.5, y: 5.5 },
                    { x: 11.5, y: 8.5 }
                ]
            },
            // –£—Ä–æ–≤–µ–Ω—å 2
            {
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1.5, y: 1.5 },
                enemies: [
                    { x: 5.5, y: 3.5, patrolPoints: [{x:5.5,y:3.5}, {x:10.5,y:3.5}, {x:10.5,y:8.5}], speed: 1.2, health: 40, damage: 15, state: 'patrol', currentIndex: 0, spriteFrame: 0 },
                    { x: 13.5, y: 12.5, patrolPoints: [{x:13.5,y:12.5}, {x:8.5,y:12.5}, {x:8.5,y:10.5}], speed: 1.5, health: 40, damage: 15, state: 'patrol', currentIndex: 0, spriteFrame: 0 },
                    { x: 3.5, y: 10.5, patrolPoints: [{x:3.5,y:10.5}, {x:6.5,y:10.5}], speed: 1, health: 40, damage: 15, state: 'patrol', currentIndex: 0, spriteFrame: 0 }
                ],
                pickups: [
                    { type: 'health', x: 4.5, y: 5.5, amount: 25 },
                    { type: 'ammo', x: 12.5, y: 4.5, amount: 30 },
                    { type: 'health', x: 9.5, y: 11.5, amount: 25 }
                ],
                torches: [
                    { x: 5.5, y: 4.5 },
                    { x: 9.5, y: 6.5 },
                    { x: 4.5, y: 11.5 }
                ]
            },
            // –£—Ä–æ–≤–µ–Ω—å 3 (—Ñ–∏–Ω–∞–ª—å–Ω—ã–π)
            {
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 14.5, y: 1.5 },
                enemies: [
                    { x: 3.5, y: 3.5, patrolPoints: [{x:3.5,y:3.5}, {x:12.5,y:3.5}, {x:12.5,y:12.5}, {x:3.5,y:12.5}], speed: 1.5, health: 50, damage: 20, state: 'patrol', currentIndex: 0, spriteFrame: 0 },
                    { x: 7.5, y: 7.5, patrolPoints: [{x:7.5,y:7.5}, {x:9.5,y:7.5}, {x:9.5,y:9.5}, {x:7.5,y:9.5}], speed: 1.8, health: 50, damage: 20, state: 'patrol', currentIndex: 0, spriteFrame: 0 },
                    { x: 2.5, y: 13.5, patrolPoints: [{x:2.5,y:13.5}, {x:5.5,y:13.5}, {x:5.5,y:11.5}], speed: 1.3, health: 50, damage: 20, state: 'patrol', currentIndex: 0, spriteFrame: 0 },
                    { x: 13.5, y: 2.5, patrolPoints: [{x:13.5,y:2.5}, {x:10.5,y:2.5}, {x:10.5,y:5.5}], speed: 1.6, health: 50, damage: 20, state: 'patrol', currentIndex: 0, spriteFrame: 0 }
                ],
                pickups: [
                    { type: 'health', x: 2.5, y: 2.5, amount: 30 },
                    { type: 'ammo', x: 13.5, y: 13.5, amount: 40 },
                    { type: 'health', x: 8.5, y: 4.5, amount: 30 },
                    { type: 'ammo', x: 4.5, y: 12.5, amount: 30 }
                ],
                torches: [
                    { x: 3.5, y: 4.5 },
                    { x: 12.5, y: 4.5 },
                    { x: 4.5, y: 12.5 },
                    { x: 12.5, y: 12.5 }
                ]
            }
        ];

        let currentLevel = 0;
        let map, enemies, pickups, torches;
        let playerX, playerY, playerAngle = 0;
        let playerSpeed = 3;
        let rotationSpeed = 0.05;
        let totalSteps = 0;
        let lastPlayerTileX, lastPlayerTileY;
        let health = 100;
        let ammo = 50;
        let gameRunning = true;
        let startTime = Date.now();
        let currentTime = 0;
        let score = 0;
        let levelScore = 0;
        let weaponLevel = 1;
        let particles = [];
        let enemySprites = []; // –î–ª—è 3D —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞

        // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ (–¥–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ)
        let moveKeys = settings.moveKeys;
        let turnKeys = settings.turnKeys;

        // –ê—É–¥–∏–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç
        let audioContext;
        let backgroundOscillator;
        let isMusicPlaying = false;
        let volume = settings.volume;

        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
            console.warn("Web Audio API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
        }

        // –†–µ–∫–æ—Ä–¥—ã
        let records = JSON.parse(localStorage.getItem('doomLabRecords')) || {
            level1: { time: Infinity, steps: Infinity, score: 0 },
            level2: { time: Infinity, steps: Infinity, score: 0 },
            level3: { time: Infinity, steps: Infinity, score: 0 }
        };

        // –ü—Ä–æ–≥—Ä–µ—Å—Å –∏–≥—Ä—ã
        let gameProgress = JSON.parse(localStorage.getItem('doomLabProgress')) || {
            currentLevel: 0,
            score: 0,
            weaponLevel: 1
        };

        // FOV
        let fov = (settings.fov * Math.PI) / 180;

        // ======================
        // –ó–í–£–ö–ò
        // ======================
        function playSound(frequency, duration, type = 'sine', vol = 0.1) {
            if (!audioContext || volume <= 0) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.value = vol * volume;
            oscillator.start();
            setTimeout(() => {
                oscillator.stop();
            }, duration);
        }

        function playFootstep() {
            playSound(150 + Math.random() * 50, 100, 'square', 0.05);
        }

        function playShot() {
            playSound(300, 50, 'sawtooth', 0.2);
            playSound(100, 150, 'square', 0.1);
            weaponEl.classList.add('weapon-recoil');
            setTimeout(() => {
                weaponEl.classList.remove('weapon-recoil');
            }, 300);
        }

        function playPickup() {
            playSound(600, 100, 'sine', 0.1);
            playSound(800, 100, 'sine', 0.1);
        }

        function playHurt() {
            playSound(200, 200, 'sawtooth', 0.15);
        }

        function playEnemyHurt() {
            playSound(150, 150, 'square', 0.1);
        }

        function playEnemyDie() {
            playSound(100, 300, 'sawtooth', 0.15);
        }

        function playVictory() {
            playSound(500, 200, 'sine', 0.1);
            setTimeout(() => playSound(600, 200, 'sine', 0.1), 250);
            setTimeout(() => playSound(700, 300, 'sine', 0.1), 500);
        }

        function playUpgrade() {
            playSound(800, 100, 'sine', 0.1);
            playSound(1000, 100, 'sine', 0.1);
            playSound(1200, 100, 'sine', 0.1);
        }

        function startBackgroundMusic() {
            if (!audioContext || isMusicPlaying) return;
            isMusicPlaying = true;
            
            function playNote(freq, duration) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.value = freq;
                gain.gain.value = 0.05 * volume;
                osc.start();
                setTimeout(() => {
                    osc.stop();
                    if (gameRunning && isMusicPlaying) {
                        scheduleNextNote();
                    }
                }, duration);
                return osc;
            }
            
            const doomNotes = [160, 180, 200, 160, 180, 200, 160, 140];
            let currentNote = 0;
            
            function scheduleNextNote() {
                const note = doomNotes[currentNote];
                currentNote = (currentNote + 1) % doomNotes.length;
                playNote(note, 400);
            }
            
            scheduleNextNote();
        }

        function stopBackgroundMusic() {
            isMusicPlaying = false;
        }

        // ======================
        // –¢–ï–ö–°–¢–£–†–´
        // ======================
        const wallTextures = {
            north: createWallTexture(64, 64, '#8b0000', '#5a0000'),
            south: createWallTexture(64, 64, '#a52a2a', '#7a1a1a'),
            east: createWallTexture(64, 64, '#b22222', '#821212'),
            west: createWallTexture(64, 64, '#800000', '#500000')
        };

        const floorColor = '#222222';
        const ceilingColor = '#111111';

        function createWallTexture(width, height, color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // –ì—Ä–∞–¥–∏–µ–Ω—Ç
            for (let y = 0; y < height; y++) {
                const ratio = y / height;
                const r = Math.floor(parseInt(color1.slice(1,3),16)*(1-ratio) + parseInt(color2.slice(1,3),16)*ratio);
                const g = Math.floor(parseInt(color1.slice(3,5),16)*(1-ratio) + parseInt(color2.slice(3,5),16)*ratio);
                const b = Math.floor(parseInt(color1.slice(5,7),16)*(1-ratio) + parseInt(color2.slice(5,7),16)*ratio);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(0, y, width, 1);
            }
            
            // –ö–∏—Ä–ø–∏—á–∏
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 16) {
                for (let y = 0; y < height; y += 16) {
                    ctx.strokeRect(x, y, 16, 16);
                }
            }
            
            return canvas;
        }

        // ======================
        // –£–ü–†–ê–í–õ–ï–ù–ò–ï
        // ======================
        const keys = {};

        function updateKeyBindings() {
            // –°–±—Ä–æ—Å–∏–º –≤—Å–µ
            for (let key in keys) {
                keys[key] = false;
            }
            // –£—Å—Ç–∞–Ω–æ–≤–∏–º –Ω–æ–≤—ã–µ
            keys[moveKeys.w] = false;
            keys[moveKeys.s] = false;
            keys['a'] = false; // –í—Å–µ–≥–¥–∞ A/D –¥–ª—è –±–æ–∫–æ–≤–æ–≥–æ –¥–≤–∏–∂–µ–Ω–∏—è
            keys['d'] = false;
            keys[turnKeys.left] = false;
            keys[turnKeys.right] = false;
            keys[' '] = false;
            keys['m'] = false;
            keys['r'] = false;
            keys['o'] = false;
        }

        updateKeyBindings();

        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
            if (e.key === 'r' || e.key === 'R') {
                restartLevel();
            }
            if (e.key === 'o' || e.key === 'O') {
                toggleSettings();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
            if (e.key === 'm' || e.key === 'M') {
                mapCanvas.style.display = mapCanvas.style.display === 'none' ? 'block' : 'none';
            }
        });

        canvas.addEventListener('click', () => {
            if (!gameRunning) return;
            fireWeapon();
        });

        // –ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        document.getElementById('btn-w')?.addEventListener('touchstart', () => keys[moveKeys.w] = true);
        document.getElementById('btn-w')?.addEventListener('touchend', () => keys[moveKeys.w] = false);
        document.getElementById('btn-s')?.addEventListener('touchstart', () => keys[moveKeys.s] = true);
        document.getElementById('btn-s')?.addEventListener('touchend', () => keys[moveKeys.s] = false);
        document.getElementById('btn-a')?.addEventListener('touchstart', () => keys.a = true);
        document.getElementById('btn-a')?.addEventListener('touchend', () => keys.a = false);
        document.getElementById('btn-d')?.addEventListener('touchstart', () => keys.d = true);
        document.getElementById('btn-d')?.addEventListener('touchend', () => keys.d = false);
        document.getElementById('btn-left')?.addEventListener('touchstart', () => keys[turnKeys.left] = true);
        document.getElementById('btn-left')?.addEventListener('touchend', () => keys[turnKeys.left] = false);
        document.getElementById('btn-right')?.addEventListener('touchstart', () => keys[turnKeys.right] = true);
        document.getElementById('btn-right')?.addEventListener('touchend', () => keys[turnKeys.right] = false);
        document.getElementById('btn-fire')?.addEventListener('click', fireWeapon);

        // ======================
        // –ß–ê–°–¢–ò–¶–´
        // ======================
        function createParticle(x, y, color = '#f00') {
            const particle = document.createElement('div');
            particle.className = 'particle';
            particle.style.left = `${x}px`;
            particle.style.top = `${y}px`;
            particle.style.background = color;
            document.body.appendChild(particle);
            
            const vx = (Math.random() - 0.5) * 5;
            const vy = (Math.random() - 0.5) * 5;
            const life = 1000 + Math.random() * 1000;
            const start = Date.now();
            
            particles.push({
                element: particle,
                x: x,
                y: y,
                vx: vx,
                vy: vy,
                life: life,
                start: start
            });
        }

        function updateParticles() {
            const now = Date.now();
            for (let i = particles.length - 1; i >= 0; i--) {
                const p = particles[i];
                const age = now - p.start;
                if (age > p.life) {
                    p.element.remove();
                    particles.splice(i, 1);
                } else {
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.05; // –≥—Ä–∞–≤–∏—Ç–∞—Ü–∏—è
                    p.element.style.left = `${p.x}px`;
                    p.element.style.top = `${p.y}px`;
                    p.element.style.opacity = 1 - age / p.life;
                }
            }
        }

        // ======================
        // –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê
        // ======================
        function initLevel(levelIndex) {
            // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å, –µ—Å–ª–∏ –Ω–∞—á–∏–Ω–∞–µ–º —Å–Ω–∞—á–∞–ª–∞
            if (levelIndex === 0) {
                score = gameProgress.score;
                weaponLevel = gameProgress.weaponLevel;
            }
            
            const level = levels[levelIndex];
            map = JSON.parse(JSON.stringify(level.map));
            enemies = JSON.parse(JSON.stringify(level.enemies));
            pickups = JSON.parse(JSON.stringify(level.pickups));
            torches = JSON.parse(JSON.stringify(level.torches || []));
            
            playerX = level.startPos.x * tileSize;
            playerY = level.startPos.y * tileSize;
            playerAngle = 0;
            totalSteps = 0;
            lastPlayerTileX = Math.floor(playerX / tileSize);
            lastPlayerTileY = Math.floor(playerY / tileSize);
            health = 100;
            ammo = 50;
            startTime = Date.now();
            gameRunning = true;
            levelScore = 0;
            levelCounterEl.textContent = levelIndex + 1;
            scoreEl.textContent = score;
            weaponLevelEl.textContent = weaponLevel;
            
            // –°–æ–∑–¥–∞–µ–º —Å–ø—Ä–∞–π—Ç—ã —Ñ–∞–∫–µ–ª–æ–≤
            createTorchLights();
            
            updateHUD();
            startBackgroundMusic();
        }

        function createTorchLights() {
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ
            document.querySelectorAll('.torch-light').forEach(el => el.remove());
            
            // –°–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–µ
            torches.forEach(torch => {
                const light = document.createElement('div');
                light.className = 'torch-light';
                light.style.left = `${torch.x * tileSize - 50}px`;
                light.style.top = `${torch.y * tileSize - 50}px`;
                document.getElementById('game-container').appendChild(light);
            });
        }

        function addScore(points) {
            levelScore += points;
            score += points;
            scoreEl.textContent = score;
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ —É–ª—É—á—à–µ–Ω–∏–µ –æ—Ä—É–∂–∏—è
            const newWeaponLevel = Math.floor(score / 100) + 1;
            if (newWeaponLevel > weaponLevel) {
                weaponLevel = newWeaponLevel;
                weaponLevelEl.textContent = weaponLevel;
                showPickupEffect(`–£–†–û–í–ï–ù–¨ –û–†–£–ñ–ò–Ø ${weaponLevel}!`, 50, 100, '#ff0', 'score-effect');
                playUpgrade();
            }
        }

        function fireWeapon() {
            if (ammo <= 0 || !gameRunning) return;
            ammo--;
            updateHUD();
            playShot();
            
            // –ß–∞—Å—Ç–∏—Ü—ã –≤—ã—Å—Ç—Ä–µ–ª–∞
            for (let i = 0; i < 5; i++) {
                const x = canvas.width / 2 + (Math.random() - 0.5) * 20;
                const y = canvas.height / 2 + (Math.random() - 0.5) * 20;
                createParticle(x, y, '#ff0');
            }
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø–æ –≤—Ä–∞–≥–∞–º
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const dx = enemy.x * tileSize - playerX;
                const dy = enemy.y * tileSize - playerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // –£–ø—Ä–æ—â—ë–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(angleToEnemy - playerAngle);
                const adjustedDiff = Math.min(angleDiff, 2*Math.PI - angleDiff);
                
                if (distance < 300 && adjustedDiff < 0.26) {
                    const damage = 25 * weaponLevel; // –£—Ä–æ–Ω –∑–∞–≤–∏—Å–∏—Ç –æ—Ç —É—Ä–æ–≤–Ω—è –æ—Ä—É–∂–∏—è
                    enemy.health -= damage;
                    playEnemyHurt();
                    
                    // –ß–∞—Å—Ç–∏—Ü—ã –∫—Ä–æ–≤–∏
                    for (let j = 0; j < 3; j++) {
                        createParticle(
                            canvas.width / 2 + (i % 3 - 1) * 30, 
                            canvas.height / 2 + Math.random() * 50, 
                            '#f00'
                        );
                    }
                    
                    if (enemy.health <= 0) {
                        playEnemyDie();
                        addScore(50); // –û—á–∫–∏ –∑–∞ —É–±–∏–π—Å—Ç–≤–æ
                        showPickupEffect("+50", 50, 100, '#ff0', 'score-effect');
                        enemies.splice(i, 1);
                        i--;
                    }
                }
            }
        }

        function checkCollision(x, y) {
            const mapX = Math.floor(x / tileSize);
            const mapY = Math.floor(y / tileSize);
            
            if (mapX < 0 || mapX >= mapSize || mapY < 0 || mapY >= mapSize) {
                return true;
            }
            
            return map[mapY][mapX] === 1;
        }

        function checkExit(x, y) {
            const mapX = Math.floor(x / tileSize);
            const mapY = Math.floor(y / tileSize);
            return map[mapY]?.[mapX] === 2;
        }

        function checkPickups() {
            for (let i = 0; i < pickups.length; i++) {
                const pickup = pickups[i];
                const dx = pickup.x * tileSize - playerX;
                const dy = pickup.y * tileSize - playerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 40) {
                    if (pickup.type === 'health') {
                        health = Math.min(100, health + pickup.amount);
                        showPickupEffect(`+${pickup.amount} ‚ù§Ô∏è`);
                        addScore(10);
                    } else if (pickup.type === 'ammo') {
                        ammo += pickup.amount;
                        showPickupEffect(`+${pickup.amount} üî´`);
                        addScore(20);
                    }
                    playPickup();
                    pickups.splice(i, 1);
                    updateHUD();
                    i--;
                }
            }
        }

        function showPickupEffect(text, x = 50, y = 100, color = '#0f0', className = 'pickup-effect') {
            const effect = document.createElement('div');
            effect.className = className;
            effect.textContent = text;
            effect.style.left = `${x}%`;
            effect.style.top = `${y}%`;
            effect.style.color = color;
            document.getElementById('game-container').appendChild(effect);
            
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 1000);
        }

        function updateEnemies() {
            // –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–µ —Å–ø—Ä–∞–π—Ç—ã
            document.querySelectorAll('.enemy-sprite').forEach(el => el.remove());
            enemySprites = [];
            
            for (let enemy of enemies) {
                // –ê–Ω–∏–º–∞—Ü–∏—è —Å–ø—Ä–∞–π—Ç–∞
                enemy.spriteFrame = (enemy.spriteFrame + 0.1) % 4;
                
                // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –∏–≥—Ä–æ–∫–∞
                const dx = playerX - enemy.x * tileSize;
                const dy = playerY - enemy.y * tileSize;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ —Ä—è–¥–æ–º ‚Äî –ø—Ä–µ—Å–ª–µ–¥–æ–≤–∞—Ç—å
                if (distance < 250) {
                    enemy.state = 'chase';
                } else if (distance > 350 && enemy.state === 'chase') {
                    enemy.state = 'patrol';
                }
                
                // –õ–æ–≥–∏–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è
                if (enemy.state === 'chase') {
                    // –î–≤–∏–≥–∞–µ–º—Å—è –∫ –∏–≥—Ä–æ–∫—É
                    const angle = Math.atan2(dy, dx);
                    const newX = enemy.x + Math.cos(angle) * enemy.speed * 0.05;
                    const newY = enemy.y + Math.sin(angle) * enemy.speed * 0.05;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
                    if (!checkEnemyCollision(newX, newY)) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                    
                    // –ê—Ç–∞–∫–∞, –µ—Å–ª–∏ —Ä—è–¥–æ–º
                    if (distance < 50) {
                        health -= enemy.damage * 0.05;
                        if (health <= 0) {
                            gameOver();
                        }
                        playHurt();
                    }
                } else {
                    // –ü–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
                    const target = enemy.patrolPoints[enemy.currentIndex];
                    const dx = target.x - enemy.x;
                    const dy = target.y - enemy.y;
                    const distToTarget = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distToTarget < 0.5) {
                        enemy.currentIndex = (enemy.currentIndex + 1) % enemy.patrolPoints.length;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        const newX = enemy.x + Math.cos(angle) * enemy.speed * 0.05;
                        const newY = enemy.y + Math.sin(angle) * enemy.speed * 0.05;
                        
                        if (!checkEnemyCollision(newX, newY)) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                    }
                }
                
                // –°–æ–∑–¥–∞–µ–º —Å–ø—Ä–∞–π—Ç –¥–ª—è 3D —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥–∞ (–±—É–¥–µ—Ç –≤ raycasting)
                enemySprites.push({
                    x: enemy.x * tileSize,
                    y: enemy.y * tileSize,
                    distance: distance,
                    frame: Math.floor(enemy.spriteFrame)
                });
            }
        }

        function checkEnemyCollision(x, y) {
            const mapX = Math.floor(x);
            const mapY = Math.floor(y);
            
            if (mapX < 0 || mapX >= mapSize || mapY < 0 || mapY >= mapSize) {
                return true;
            }
            
            return map[mapY][mapX] !== 0;
        }

        function updatePlayer() {
            if (!gameRunning) return;

            // –ü–æ–≤–æ—Ä–æ—Ç
            if (keys[turnKeys.left]) playerAngle -= rotationSpeed;
            if (keys[turnKeys.right]) playerAngle += rotationSpeed;

            // –î–≤–∏–∂–µ–Ω–∏–µ
            let moveX = 0;
            let moveY = 0;
            let moved = false;

            if (keys[moveKeys.w]) {
                moveX += Math.cos(playerAngle) * playerSpeed;
                moveY += Math.sin(playerAngle) * playerSpeed;
                moved = true;
            }
            if (keys[moveKeys.s]) {
                moveX -= Math.cos(playerAngle) * playerSpeed;
                moveY -= Math.sin(playerAngle) * playerSpeed;
                moved = true;
            }
            if (keys.a) {
                moveX += Math.cos(playerAngle - Math.PI/2) * playerSpeed;
                moveY += Math.sin(playerAngle - Math.PI/2) * playerSpeed;
                moved = true;
            }
            if (keys.d) {
                moveX += Math.cos(playerAngle + Math.PI/2) * playerSpeed;
                moveY += Math.sin(playerAngle + Math.PI/2) * playerSpeed;
                moved = true;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            if (!checkCollision(playerX + moveX, playerY)) {
                playerX += moveX;
                moved = true;
            }
            if (!checkCollision(playerX, playerY + moveY)) {
                playerY += moveY;
                moved = true;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞
            if (checkExit(playerX, playerY)) {
                completeLevel();
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–±–æ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç–æ–≤
            checkPickups();

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
            updateEnemies();

            // –ü–æ–¥—Å—á—ë—Ç —à–∞–≥–æ–≤
            const currentTileX = Math.floor(playerX / tileSize);
            const currentTileY = Math.floor(playerY / tileSize);
            if (currentTileX !== lastPlayerTileX || currentTileY !== lastPlayerTileY) {
                totalSteps++;
                lastPlayerTileX = currentTileX;
                lastPlayerTileY = currentTileY;
                if (moved) playFootstep();
            }

            updateHUD();
            updateParticles();
        }

        function updateHUD() {
            healthEl.textContent = Math.ceil(health);
            ammoEl.textContent = ammo;
            healthEl.style.color = health > 50 ? '#fff' : health > 25 ? '#ff0' : '#f00';
        }

        function completeLevel() {
            gameRunning = false;
            stopBackgroundMusic();
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            
            // –ë–æ–Ω—É—Å –∑–∞ –±—ã—Å—Ç—Ä–æ–µ –ø—Ä–æ—Ö–æ–∂–¥–µ–Ω–∏–µ
            const timeBonus = Math.max(0, 100 - elapsed);
            if (timeBonus > 0) {
                addScore(timeBonus);
                showPickupEffect(`+${timeBonus} –∑–∞ —Å–∫–æ—Ä–æ—Å—Ç—å!`, 50, 50, '#0ff', 'score-effect');
            }
            
            finalTimeEl.textContent = `${minutes}:${seconds}`;
            finalStepsEl.textContent = totalSteps;
            completedLevelEl.textContent = currentLevel + 1;
            document.getElementById('level-score').textContent = levelScore;
            document.getElementById('total-score').textContent = score;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–∫–æ—Ä–¥–æ–≤
            const levelKey = `level${currentLevel + 1}`;
            if (elapsed < records[levelKey].time) {
                records[levelKey].time = elapsed;
            }
            if (totalSteps < records[levelKey].steps) {
                records[levelKey].steps = totalSteps;
            }
            if (score > records[levelKey].score) {
                records[levelKey].score = score;
            }
            localStorage.setItem('doomLabRecords', JSON.stringify(records));
            
            // –°–æ—Ö—Ä–∞–Ω—è–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
            gameProgress.currentLevel = (currentLevel + 1) % levels.length;
            gameProgress.score = score;
            gameProgress.weaponLevel = weaponLevel;
            localStorage.setItem('doomLabProgress', JSON.stringify(gameProgress));
            
            // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∫–æ—Ä–¥–æ–≤
            displayRecords();
            
            victoryScreen.style.display = 'flex';
            playVictory();
        }

        function displayRecords() {
            let html = '<h3>–õ—É—á—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:</h3>';
            for (let i = 0; i < 3; i++) {
                const levelKey = `level${i + 1}`;
                const record = records[levelKey];
                const timeStr = record.time === Infinity ? "--:--" : 
                    `${Math.floor(record.time / 60).toString().padStart(2, '0')}:${(record.time % 60).toString().padStart(2, '0')}`;
                const stepsStr = record.steps === Infinity ? "---" : record.steps;
                const scoreStr = record.score || 0;
                html += `<div>–£—Ä–æ–≤–µ–Ω—å ${i + 1}: ${timeStr} | ${stepsStr} —à–∞–≥–æ–≤ | ${scoreStr} –æ—á–∫–æ–≤</div>`;
            }
            bestRecordsEl.innerHTML = html;
        }

        function gameOver() {
            gameRunning = false;
            stopBackgroundMusic();
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            
            deathTimeEl.textContent = `${minutes}:${seconds}`;
            deathStepsEl.textContent = totalSteps;
            document.getElementById('death-score').textContent = score;
            
            gameOverScreen.style.display = 'flex';
        }

        function nextLevel() {
            currentLevel = (currentLevel + 1) % levels.length;
            victoryScreen.style.display = 'none';
            initLevel(currentLevel);
        }

        function restartGame() {
            currentLevel = 0;
            score = 0;
            weaponLevel = 1;
            gameProgress = { currentLevel: 0, score: 0, weaponLevel: 1 };
            victoryScreen.style.display = 'none';
            initLevel(currentLevel);
        }

        function restartLevel() {
            initLevel(currentLevel);
        }

        function retry() {
            gameOverScreen.style.display = 'none';
            initLevel(currentLevel);
        }

        function toggleSettings() {
            if (settingsScreen.style.display === 'flex') {
                settingsScreen.style.display = 'none';
            } else {
                settingsScreen.style.display = 'flex';
            }
        }

        // ======================
        // –ù–ê–°–¢–†–û–ô–ö–ò
        // ======================
        volumeSlider.addEventListener('input', () => {
            volume = parseFloat(volumeSlider.value);
            volumeDisplay.textContent = Math.round(volume * 100) + '%';
        });

        fovSlider.addEventListener('input', () => {
            fov = (parseInt(fovSlider.value) * Math.PI) / 180;
            fovDisplay.textContent = fovSlider.value + '¬∞';
        });

        saveSettingsBtn.addEventListener('click', () => {
            settings = {
                volume: volume,
                fov: parseInt(fovSlider.value),
                moveKeys: {
                    w: moveKeyW.value,
                    s: moveKeyS.value
                },
                turnKeys: {
                    left: turnKeyLeft.value,
                    right: turnKeyRight.value
                }
            };
            localStorage.setItem('doomLabSettings', JSON.stringify(settings));
            updateKeyBindings();
            alert('–ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω—ã!');
            settingsScreen.style.display = 'none';
        });

        closeSettingsBtn.addEventListener('click', () => {
            settingsScreen.style.display = 'none';
        });

        settingsToggle.addEventListener('click', toggleSettings);

        // ======================
        // –†–ï–ù–î–ï–†–ò–ù–ì
        // ======================
        function render() {
            if (!gameRunning) return;

            // –û—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞
            ctx.fillStyle = ceilingColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
            ctx.fillStyle = floorColor;
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

            // Raycasting
            const rayCount = canvas.width;
            const rayStep = fov / rayCount;

            // –°–Ω–∞—á–∞–ª–∞ —Å—Ç–µ–Ω—ã
            for (let i = 0; i < rayCount; i++) {
                const rayAngle = playerAngle - fov / 2 + i * rayStep;
                let distance = 0;
                let hitWall = false;
                let wallSide = 'north';

                while (!hitWall && distance < mapSize * tileSize) {
                    distance += 0.5;
                    
                    const rayX = playerX + Math.cos(rayAngle) * distance;
                    const rayY = playerY + Math.sin(rayAngle) * distance;
                    
                    const mapX = Math.floor(rayX / tileSize);
                    const mapY = Math.floor(rayY / tileSize);
                    
                    if (mapX < 0 || mapX >= mapSize || mapY < 0 || mapY >= mapSize) {
                        hitWall = true;
                        distance = mapSize * tileSize;
                    } else if (map[mapY][mapX] !== 0) {
                        hitWall = true;
                        
                        const blockX = mapX * tileSize;
                        const blockY = mapY * tileSize;
                        const testPointX = (rayX - blockX) / tileSize;
                        const testPointY = (rayY - blockY) / tileSize;
                        
                        if (testPointX < 0.01) {
                            wallSide = 'west';
                        } else if (testPointX > 0.99) {
                            wallSide = 'east';
                        } else if (testPointY < 0.01) {
                            wallSide = 'north';
                        } else if (testPointY > 0.99) {
                            wallSide = 'south';
                        }
                    }
                }

                const correctedDistance = distance * Math.cos(rayAngle - playerAngle);
                const wallHeight = Math.min(5000, (tileSize / correctedDistance) * ((canvas.width / 2) / Math.tan(fov / 2)));
                
                const texture = wallTextures[wallSide];
                const texX = Math.floor((i / rayCount) * texture.width) % texture.width;
                
                const darkness = Math.min(1, correctedDistance / (tileSize * 8));
                ctx.globalAlpha = 1 - darkness * 0.7;
                
                ctx.drawImage(
                    texture,
                    texX, 0, 1, texture.height,
                    i, canvas.height / 2 - wallHeight / 2, 1, wallHeight
                );
                
                ctx.globalAlpha = 1;
            }

            // –°–ø—Ä–∞–π—Ç—ã –≤—Ä–∞–≥–æ–≤ (—É–ø—Ä–æ—â—ë–Ω–Ω—ã–π –±–∏–Ω-—Å–æ—Ä—Ç–∏—Ä–æ–≤–∞–Ω–Ω—ã–π —Ä–µ–Ω–¥–µ—Ä–∏–Ω–≥)
            enemySprites.sort((a, b) => b.distance - a.distance); // –¥–∞–ª—å–Ω–∏–µ –ø–µ—Ä–≤—ã–º–∏
            for (let sprite of enemySprites) {
                const dx = sprite.x - playerX;
                const dy = sprite.y - playerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // –£–≥–æ–ª –º–µ–∂–¥—É —Å–ø—Ä–∞–π—Ç–æ–º –∏ –Ω–∞–ø—Ä–∞–≤–ª–µ–Ω–∏–µ–º –≤–∑–≥–ª—è–¥–∞
                const angle = Math.atan2(dy, dx) - playerAngle;
                const correctedAngle = angle - Math.floor(angle / (2*Math.PI) + 0.5) * 2*Math.PI;
                
                // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤–∏–¥–∏–º–æ—Å—Ç–∏
                if (Math.abs(correctedAngle) < fov / 2) {
                    const spriteScreenX = canvas.width / 2 + (correctedAngle / (fov / 2)) * (canvas.width / 2);
                    const spriteHeight = (tileSize / distance) * ((canvas.width / 2) / Math.tan(fov / 2));
                    
                    // –†–∏—Å—É–µ–º —Å–ø—Ä–∞–π—Ç (–∑–∞–≥–ª—É—à–∫–∞ ‚Äî –∫—Ä–∞—Å–Ω—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫)
                    ctx.fillStyle = '#f00';
                    ctx.globalAlpha = 0.8;
                    ctx.fillRect(
                        spriteScreenX - spriteHeight / 4,
                        canvas.height / 2 - spriteHeight / 2,
                        spriteHeight / 2,
                        spriteHeight
                    );
                    ctx.globalAlpha = 1;
                }
            }

            renderMinimap();
            updateTimer();
        }

        function renderMinimap() {
            const cellSize = mapCanvas.width / mapSize;
            mapCtx.fillStyle = '#000';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

            // –°—Ç–µ–Ω—ã, –≤—ã—Ö–æ–¥
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    if (map[y][x] === 1) {
                        mapCtx.fillStyle = '#f00';
                        mapCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    } else if (map[y][x] === 2) {
                        mapCtx.fillStyle = '#0f0';
                        mapCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // –ü—Ä–µ–¥–º–µ—Ç—ã
            for (let pickup of pickups) {
                mapCtx.fillStyle = pickup.type === 'health' ? '#0f0' : '#ff0';
                mapCtx.beginPath();
                mapCtx.arc(
                    pickup.x * cellSize, 
                    pickup.y * cellSize, 
                    cellSize / 4, 0, Math.PI * 2
                );
                mapCtx.fill();
            }

            // –í—Ä–∞–≥–∏
            for (let enemy of enemies) {
                mapCtx.fillStyle = enemy.state === 'chase' ? '#f00' : '#faa';
                mapCtx.beginPath();
                mapCtx.arc(
                    enemy.x * cellSize, 
                    enemy.y * cellSize, 
                    cellSize / 3, 0, Math.PI * 2
                );
                mapCtx.fill();
            }

            // –ò–≥—Ä–æ–∫
            const playerMapX = (playerX / tileSize) * cellSize;
            const playerMapY = (playerY / tileSize) * cellSize;
            mapCtx.fillStyle = '#0f0';
            mapCtx.beginPath();
            mapCtx.arc(playerMapX, playerMapY, cellSize / 3, 0, Math.PI * 2);
            mapCtx.fill();
            mapCtx.strokeStyle = '#0f0';
            mapCtx.beginPath();
            mapCtx.moveTo(playerMapX, playerMapY);
            mapCtx.lineTo(
                playerMapX + Math.cos(playerAngle) * cellSize,
                playerMapY + Math.sin(playerAngle) * cellSize
            );
            mapCtx.stroke();
        }

        function updateTimer() {
            if (!gameRunning) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            timerEl.textContent = `${minutes}:${seconds}`;
        }

        // ======================
        // –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
        // ======================
        function gameLoop() {
            updatePlayer();
            render();
            requestAnimationFrame(gameLoop);
        }

        // ======================
        // –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø
        // ======================
        nextLevelBtn.addEventListener('click', nextLevel);
        restartGameBtn.addEventListener('click', restartGame);
        retryBtn.addEventListener('click', retry);

        // –ó–∞–≥—Ä—É–∂–∞–µ–º –ø—Ä–æ–≥—Ä–µ—Å—Å
        currentLevel = gameProgress.currentLevel;
        score = gameProgress.score;
        weaponLevel = gameProgress.weaponLevel;

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–π —É—Ä–æ–≤–µ–Ω—å
        initLevel(currentLevel);
        gameLoop();
        displayRecords();
    </script>
</body>
</html>

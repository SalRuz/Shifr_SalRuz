<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Doom Lab ‚Äî –ü–æ–ª–Ω–∞—è –≤–µ—Ä—Å–∏—è</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Courier New', monospace;
            color: #ff0000;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }
        
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
            max-width: 100%;
            max-height: 100%;
        }
        
        #game-canvas {
            position: absolute;
            width: 100%;
            height: 100%;
            image-rendering: pixelated;
        }
        
        #ui {
            position: absolute;
            bottom: 0;
            width: 100%;
            height: 100px;
            background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
            color: #fff;
            font-size: 16px;
            text-shadow: 2px 2px 0 #000;
        }
        
        #weapon {
            width: 300px;
            height: 180px;
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="300" height="180" viewBox="0 0 300 180"><path d="M150,180 L140,120 L160,120 Z" fill="%23333"/><rect x="130" y="80" width="40" height="40" fill="%23555"/><rect x="135" y="85" width="30" height="30" fill="%23777"/></svg>') no-repeat center bottom;
            image-rendering: pixelated;
            cursor: crosshair;
            transition: transform 0.1s;
        }
        
        #hud {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            height: 80px;
            padding: 5px 0;
        }
        
        #instructions {
            position: absolute;
            top: 20px;
            left: 20px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border: 2px solid #ff0000;
            font-size: 14px;
            z-index: 10;
        }
        
        #map {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 150px;
            height: 150px;
            background-color: rgba(0, 0, 0, 0.7);
            border: 2px solid #ff0000;
            z-index: 5;
        }

        .mobile-controls {
            display: none;
            position: absolute;
            bottom: 20px;
            width: 100%;
            z-index: 20;
        }

        .mobile-controls button {
            background: rgba(255,0,0,0.5);
            border: 2px solid #ff0000;
            color: white;
            font-size: 24px;
            width: 60px;
            height: 60px;
            margin: 5px;
            border-radius: 10px;
            touch-action: manipulation;
        }

        .dpad {
            display: grid;
            grid-template-columns: 60px 60px 60px;
            grid-template-rows: 60px 60px 60px;
            gap: 5px;
            position: absolute;
            left: 20px;
            bottom: 20px;
        }

        .dpad button:nth-child(5) { grid-column: 2; grid-row: 2; } /* S */
        .dpad button:nth-child(2) { grid-column: 2; grid-row: 1; } /* W */
        .dpad button:nth-child(4) { grid-column: 1; grid-row: 2; } /* A */
        .dpad button:nth-child(6) { grid-column: 3; grid-row: 2; } /* D */

        .turn-controls {
            position: absolute;
            right: 20px;
            bottom: 20px;
            display: flex;
            gap: 10px;
        }

        @media (max-width: 850px) {
            .mobile-controls { display: block; }
            #instructions { font-size: 12px; padding: 8px; }
        }

        #victory-screen, #game-over-screen {
            display: none;
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.9);
            color: #ff0000;
            font-size: 36px;
            font-weight: bold;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            text-align: center;
            padding: 20px;
            box-sizing: border-box;
        }

        #victory-screen h2, #game-over-screen h2 {
            font-size: 48px;
            margin: 0 0 20px;
        }

        #victory-screen button, #game-over-screen button {
            margin-top: 30px;
            padding: 15px 30px;
            font-size: 24px;
            background: #ff0000;
            color: white;
            border: none;
            cursor: pointer;
            margin: 10px;
        }

        .records {
            margin: 20px 0;
            font-size: 20px;
            max-width: 600px;
        }

        .level-indicator {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            padding: 5px 15px;
            border: 2px solid #f00;
            font-size: 20px;
            z-index: 15;
        }

        .pickup-effect {
            position: absolute;
            color: #0f0;
            font-size: 24px;
            font-weight: bold;
            pointer-events: none;
            animation: float-up 1s ease-out forwards;
            z-index: 100;
        }

        @keyframes float-up {
            0% { opacity: 1; transform: translateY(0); }
            100% { opacity: 0; transform: translateY(-50px); }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        
        <div class="level-indicator">–£—Ä–æ–≤–µ–Ω—å: <span id="level-counter">1</span></div>
        
        <div id="ui">
            <div id="hud">
                <div>–ó–¥–æ—Ä–æ–≤—å–µ: <span id="health">100</span></div>
                <div>–ü–∞—Ç—Ä–æ–Ω—ã: <span id="ammo">50</span></div>
                <div>–í—Ä–µ–º—è: <span id="timer">00:00</span></div>
                <div>–®–∞–≥–æ–≤: <span id="steps">0</span></div>
            </div>
            <div id="weapon"></div>
        </div>
        
        <div id="instructions">
            <p>WASD ‚Äî –¥–≤–∏–∂–µ–Ω–∏–µ | ‚Üê ‚Üí ‚Äî –ø–æ–≤–æ—Ä–æ—Ç</p>
            <p>–ü—Ä–æ–±–µ–ª –∏–ª–∏ –∫–ª–∏–∫ ‚Äî –≤—ã—Å—Ç—Ä–µ–ª</p>
            <p>M ‚Äî –∫–∞—Ä—Ç–∞ | R ‚Äî –ø–µ—Ä–µ–∑–∞–ø—É—Å–∫ —É—Ä–æ–≤–Ω—è</p>
            <p>–ù–∞–π–¥–∏—Ç–µ –≤—ã—Ö–æ–¥ (–∑–µ–ª—ë–Ω–∞—è –¥–≤–µ—Ä—å)!</p>
        </div>
        
        <canvas id="map"></canvas>

        <div class="mobile-controls">
            <div class="dpad">
                <button id="btn-w">W</button>
                <button id="btn-a">A</button>
                <button id="btn-s">S</button>
                <button id="btn-d">D</button>
            </div>
            <div class="turn-controls">
                <button id="btn-left">‚Üê</button>
                <button id="btn-right">‚Üí</button>
                <button id="btn-fire">üî´</button>
            </div>
        </div>

        <div id="victory-screen">
            <h2>–ü–û–ë–ï–î–ê!</h2>
            <div>–í—ã –ø—Ä–æ—à–ª–∏ —É—Ä–æ–≤–µ–Ω—å <span id="completed-level">1</span>!</div>
            <div>–í—Ä–µ–º—è: <span id="final-time">00:00</span></div>
            <div>–®–∞–≥–æ–≤: <span id="final-steps">0</span></div>
            <div class="records" id="best-records"></div>
            <div>
                <button id="next-level-btn">–°–ª–µ–¥—É—é—â–∏–π —É—Ä–æ–≤–µ–Ω—å</button>
                <button id="restart-game-btn">–ù–∞—á–∞—Ç—å –∑–∞–Ω–æ–≤–æ</button>
            </div>
        </div>

        <div id="game-over-screen">
            <h2>–í–´ –ü–û–ì–ò–ë–õ–ò</h2>
            <div>–í—Ä–∞–≥–∏ –æ–∫–∞–∑–∞–ª–∏—Å—å —Å–∏–ª—å–Ω–µ–µ...</div>
            <div>–í—Ä–µ–º—è: <span id="death-time">00:00</span></div>
            <div>–®–∞–≥–æ–≤: <span id="death-steps">0</span></div>
            <button id="retry-btn">–ü–æ–ø—Ä–æ–±–æ–≤–∞—Ç—å —Å–Ω–æ–≤–∞</button>
        </div>
    </div>

    <script>
        // ======================
        // –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï
        // ======================
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const mapCanvas = document.getElementById('map');
        const mapCtx = mapCanvas.getContext('2d');
        const weaponEl = document.getElementById('weapon');
        const healthEl = document.getElementById('health');
        const ammoEl = document.getElementById('ammo');
        const timerEl = document.getElementById('timer');
        const stepsEl = document.getElementById('steps');
        const levelCounterEl = document.getElementById('level-counter');
        const victoryScreen = document.getElementById('victory-screen');
        const gameOverScreen = document.getElementById('game-over-screen');
        const finalTimeEl = document.getElementById('final-time');
        const finalStepsEl = document.getElementById('final-steps');
        const deathTimeEl = document.getElementById('death-time');
        const deathStepsEl = document.getElementById('death-steps');
        const completedLevelEl = document.getElementById('completed-level');
        const bestRecordsEl = document.getElementById('best-records');
        const nextLevelBtn = document.getElementById('next-level-btn');
        const restartGameBtn = document.getElementById('restart-game-btn');
        const retryBtn = document.getElementById('retry-btn');

        canvas.width = 800;
        canvas.height = 600;
        mapCanvas.width = 150;
        mapCanvas.height = 150;

        const mapSize = 16;
        const tileSize = 64;

        // –¢—Ä–∏ —É—Ä–æ–≤–Ω—è
        const levels = [
            // –£—Ä–æ–≤–µ–Ω—å 1
            {
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1.5, y: 1.5 },
                enemies: [
                    { x: 4.5, y: 4.5, patrolPoints: [{x:4.5,y:4.5}, {x:8.5,y:4.5}], speed: 0.8, health: 30, damage: 10, state: 'patrol', currentIndex: 0 },
                    { x: 12.5, y: 10.5, patrolPoints: [{x:12.5,y:10.5}, {x:12.5,y:6.5}], speed: 1, health: 30, damage: 10, state: 'patrol', currentIndex: 0 }
                ],
                pickups: [
                    { type: 'health', x: 3.5, y: 3.5, amount: 25 },
                    { type: 'ammo', x: 10.5, y: 3.5, amount: 20 }
                ]
            },
            // –£—Ä–æ–≤–µ–Ω—å 2
            {
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 1.5, y: 1.5 },
                enemies: [
                    { x: 5.5, y: 3.5, patrolPoints: [{x:5.5,y:3.5}, {x:10.5,y:3.5}, {x:10.5,y:8.5}], speed: 1.2, health: 40, damage: 15, state: 'patrol', currentIndex: 0 },
                    { x: 13.5, y: 12.5, patrolPoints: [{x:13.5,y:12.5}, {x:8.5,y:12.5}, {x:8.5,y:10.5}], speed: 1.5, health: 40, damage: 15, state: 'patrol', currentIndex: 0 },
                    { x: 3.5, y: 10.5, patrolPoints: [{x:3.5,y:10.5}, {x:6.5,y:10.5}], speed: 1, health: 40, damage: 15, state: 'patrol', currentIndex: 0 }
                ],
                pickups: [
                    { type: 'health', x: 4.5, y: 5.5, amount: 25 },
                    { type: 'ammo', x: 12.5, y: 4.5, amount: 30 },
                    { type: 'health', x: 9.5, y: 11.5, amount: 25 }
                ]
            },
            // –£—Ä–æ–≤–µ–Ω—å 3 (—Ñ–∏–Ω–∞–ª—å–Ω—ã–π)
            {
                map: [
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
                    [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1],
                    [1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1],
                    [1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1],
                    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1],
                    [1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1],
                    [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
                ],
                startPos: { x: 14.5, y: 1.5 }, // –ù–∞—á–∏–Ω–∞–µ–º —É –≤—ã—Ö–æ–¥–∞ –ø—Ä–µ–¥—ã–¥—É—â–µ–≥–æ —É—Ä–æ–≤–Ω—è
                enemies: [
                    { x: 3.5, y: 3.5, patrolPoints: [{x:3.5,y:3.5}, {x:12.5,y:3.5}, {x:12.5,y:12.5}, {x:3.5,y:12.5}], speed: 1.5, health: 50, damage: 20, state: 'patrol', currentIndex: 0 },
                    { x: 7.5, y: 7.5, patrolPoints: [{x:7.5,y:7.5}, {x:9.5,y:7.5}, {x:9.5,y:9.5}, {x:7.5,y:9.5}], speed: 1.8, health: 50, damage: 20, state: 'patrol', currentIndex: 0 },
                    { x: 2.5, y: 13.5, patrolPoints: [{x:2.5,y:13.5}, {x:5.5,y:13.5}, {x:5.5,y:11.5}], speed: 1.3, health: 50, damage: 20, state: 'patrol', currentIndex: 0 },
                    { x: 13.5, y: 2.5, patrolPoints: [{x:13.5,y:2.5}, {x:10.5,y:2.5}, {x:10.5,y:5.5}], speed: 1.6, health: 50, damage: 20, state: 'patrol', currentIndex: 0 }
                ],
                pickups: [
                    { type: 'health', x: 2.5, y: 2.5, amount: 30 },
                    { type: 'ammo', x: 13.5, y: 13.5, amount: 40 },
                    { type: 'health', x: 8.5, y: 4.5, amount: 30 },
                    { type: 'ammo', x: 4.5, y: 12.5, amount: 30 }
                ]
            }
        ];

        let currentLevel = 0;
        let map, enemies, pickups;
        let playerX, playerY, playerAngle = 0;
        let playerSpeed = 3;
        let rotationSpeed = 0.05;
        let totalSteps = 0;
        let lastPlayerTileX, lastPlayerTileY;
        let health = 100;
        let ammo = 50;
        let gameRunning = true;
        let startTime = Date.now();
        let currentTime = 0;

        // –ê–Ω–∏–º–∞—Ü–∏—è –æ—Ä—É–∂–∏—è
        let weaponRecoil = 0;

        // –ê—É–¥–∏–æ –∫–æ–Ω—Ç–µ–∫—Å—Ç
        let audioContext;
        let backgroundOscillator;
        let isMusicPlaying = false;

        try {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
        } catch(e) {
            console.warn("Web Audio API –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è");
        }

        // –†–µ–∫–æ—Ä–¥—ã
        let records = JSON.parse(localStorage.getItem('doomLabRecords')) || {
            level1: { time: Infinity, steps: Infinity },
            level2: { time: Infinity, steps: Infinity },
            level3: { time: Infinity, steps: Infinity }
        };

        // ======================
        // –ó–í–£–ö–ò
        // ======================
        function playSound(frequency, duration, type = 'sine', volume = 0.1) {
            if (!audioContext) return;
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            oscillator.frequency.value = frequency;
            oscillator.type = type;
            gainNode.gain.value = volume;
            oscillator.start();
            setTimeout(() => {
                oscillator.stop();
            }, duration);
        }

        function playFootstep() {
            playSound(150 + Math.random() * 50, 100, 'square', 0.05);
        }

        function playShot() {
            playSound(300, 50, 'sawtooth', 0.2);
            playSound(100, 150, 'square', 0.1);
            weaponRecoil = 10;
        }

        function playPickup() {
            playSound(600, 100, 'sine', 0.1);
            playSound(800, 100, 'sine', 0.1);
        }

        function playHurt() {
            playSound(200, 200, 'sawtooth', 0.15);
        }

        function playEnemyHurt() {
            playSound(150, 150, 'square', 0.1);
        }

        function playEnemyDie() {
            playSound(100, 300, 'sawtooth', 0.15);
        }

        function playVictory() {
            playSound(500, 200, 'sine', 0.1);
            setTimeout(() => playSound(600, 200, 'sine', 0.1), 250);
            setTimeout(() => playSound(700, 300, 'sine', 0.1), 500);
        }

        function startBackgroundMusic() {
            if (!audioContext || isMusicPlaying) return;
            isMusicPlaying = true;
            
            function playNote(freq, duration) {
                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();
                osc.connect(gain);
                gain.connect(audioContext.destination);
                osc.frequency.value = freq;
                gain.gain.value = 0.05;
                osc.start();
                setTimeout(() => {
                    osc.stop();
                    if (gameRunning && isMusicPlaying) {
                        scheduleNextNote();
                    }
                }, duration);
                return osc;
            }
            
            const doomNotes = [160, 180, 200, 160, 180, 200, 160, 140];
            let currentNote = 0;
            
            function scheduleNextNote() {
                const note = doomNotes[currentNote];
                currentNote = (currentNote + 1) % doomNotes.length;
                playNote(note, 400);
            }
            
            scheduleNextNote();
        }

        function stopBackgroundMusic() {
            isMusicPlaying = false;
        }

        // ======================
        // –¢–ï–ö–°–¢–£–†–´
        // ======================
        const wallTextures = {
            north: createWallTexture(64, 64, '#8b0000', '#5a0000'),
            south: createWallTexture(64, 64, '#a52a2a', '#7a1a1a'),
            east: createWallTexture(64, 64, '#b22222', '#821212'),
            west: createWallTexture(64, 64, '#800000', '#500000')
        };

        const floorColor = '#222222';
        const ceilingColor = '#111111';

        function createWallTexture(width, height, color1, color2) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            
            // –ì—Ä–∞–¥–∏–µ–Ω—Ç
            for (let y = 0; y < height; y++) {
                const ratio = y / height;
                const r = Math.floor(parseInt(color1.slice(1,3),16)*(1-ratio) + parseInt(color2.slice(1,3),16)*ratio);
                const g = Math.floor(parseInt(color1.slice(3,5),16)*(1-ratio) + parseInt(color2.slice(3,5),16)*ratio);
                const b = Math.floor(parseInt(color1.slice(5,7),16)*(1-ratio) + parseInt(color2.slice(5,7),16)*ratio);
                ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                ctx.fillRect(0, y, width, 1);
            }
            
            // –ö–∏—Ä–ø–∏—á–∏
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 1;
            for (let x = 0; x < width; x += 16) {
                for (let y = 0; y < height; y += 16) {
                    ctx.strokeRect(x, y, 16, 16);
                }
            }
            
            return canvas;
        }

        // ======================
        // –£–ü–†–ê–í–õ–ï–ù–ò–ï
        // ======================
        const keys = {
            w: false,
            a: false,
            s: false,
            d: false,
            ArrowLeft: false,
            ArrowRight: false,
            ' ': false
        };

        window.addEventListener('keydown', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = true;
            }
            if (e.key === 'r' || e.key === 'R') {
                restartLevel();
            }
        });

        window.addEventListener('keyup', (e) => {
            if (keys.hasOwnProperty(e.key)) {
                keys[e.key] = false;
            }
            if (e.key === 'm' || e.key === 'M') {
                mapCanvas.style.display = mapCanvas.style.display === 'none' ? 'block' : 'none';
            }
        });

        canvas.addEventListener('click', () => {
            if (!gameRunning) return;
            fireWeapon();
        });

        // –ú–æ–±–∏–ª—å–Ω–æ–µ —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
        document.getElementById('btn-w')?.addEventListener('touchstart', () => keys.w = true);
        document.getElementById('btn-w')?.addEventListener('touchend', () => keys.w = false);
        document.getElementById('btn-s')?.addEventListener('touchstart', () => keys.s = true);
        document.getElementById('btn-s')?.addEventListener('touchend', () => keys.s = false);
        document.getElementById('btn-a')?.addEventListener('touchstart', () => keys.a = true);
        document.getElementById('btn-a')?.addEventListener('touchend', () => keys.a = false);
        document.getElementById('btn-d')?.addEventListener('touchstart', () => keys.d = true);
        document.getElementById('btn-d')?.addEventListener('touchend', () => keys.d = false);
        document.getElementById('btn-left')?.addEventListener('touchstart', () => keys.ArrowLeft = true);
        document.getElementById('btn-left')?.addEventListener('touchend', () => keys.ArrowLeft = false);
        document.getElementById('btn-right')?.addEventListener('touchstart', () => keys.ArrowRight = true);
        document.getElementById('btn-right')?.addEventListener('touchend', () => keys.ArrowRight = false);
        document.getElementById('btn-fire')?.addEventListener('click', fireWeapon);

        // ======================
        // –ò–ì–†–û–í–ê–Ø –õ–û–ì–ò–ö–ê
        // ======================
        function initLevel(levelIndex) {
            const level = levels[levelIndex];
            map = JSON.parse(JSON.stringify(level.map)); // –ì–ª—É–±–æ–∫–æ–µ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏–µ
            enemies = JSON.parse(JSON.stringify(level.enemies));
            pickups = JSON.parse(JSON.stringify(level.pickups));
            
            playerX = level.startPos.x * tileSize;
            playerY = level.startPos.y * tileSize;
            playerAngle = 0;
            totalSteps = 0;
            lastPlayerTileX = Math.floor(playerX / tileSize);
            lastPlayerTileY = Math.floor(playerY / tileSize);
            health = 100;
            ammo = 50;
            startTime = Date.now();
            gameRunning = true;
            levelCounterEl.textContent = levelIndex + 1;
            
            updateHUD();
            startBackgroundMusic();
        }

        function fireWeapon() {
            if (ammo <= 0 || !gameRunning) return;
            ammo--;
            updateHUD();
            playShot();
            showBloodSplash();
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è –ø–æ –≤—Ä–∞–≥–∞–º
            for (let i = 0; i < enemies.length; i++) {
                const enemy = enemies[i];
                const dx = enemy.x * tileSize - playerX;
                const dy = enemy.y * tileSize - playerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // –£–ø—Ä–æ—â—ë–Ω–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–ø–∞–¥–∞–Ω–∏—è (–≤ –ø—Ä–µ–¥–µ–ª–∞—Ö 30 –≥—Ä–∞–¥—É—Å–æ–≤ –∏ 300 –ø–∏–∫—Å–µ–ª–µ–π)
                const angleToEnemy = Math.atan2(dy, dx);
                const angleDiff = Math.abs(angleToEnemy - playerAngle);
                const adjustedDiff = Math.min(angleDiff, 2*Math.PI - angleDiff);
                
                if (distance < 300 && adjustedDiff < 0.26) { // ~15 –≥—Ä–∞–¥—É—Å–æ–≤
                    enemy.health -= 25;
                    playEnemyHurt();
                    if (enemy.health <= 0) {
                        playEnemyDie();
                        enemies.splice(i, 1);
                        i--;
                    }
                }
            }
        }

        function showBloodSplash() {
            weaponEl.style.transform = `translateY(${weaponRecoil}px)`;
            setTimeout(() => {
                weaponRecoil *= 0.7;
                if (Math.abs(weaponRecoil) > 0.1) {
                    weaponEl.style.transform = `translateY(${weaponRecoil}px)`;
                    requestAnimationFrame(showBloodSplash);
                } else {
                    weaponEl.style.transform = '';
                }
            }, 30);
        }

        function checkCollision(x, y) {
            const mapX = Math.floor(x / tileSize);
            const mapY = Math.floor(y / tileSize);
            
            if (mapX < 0 || mapX >= mapSize || mapY < 0 || mapY >= mapSize) {
                return true;
            }
            
            return map[mapY][mapX] === 1;
        }

        function checkExit(x, y) {
            const mapX = Math.floor(x / tileSize);
            const mapY = Math.floor(y / tileSize);
            return map[mapY]?.[mapX] === 2;
        }

        function checkPickups() {
            for (let i = 0; i < pickups.length; i++) {
                const pickup = pickups[i];
                const dx = pickup.x * tileSize - playerX;
                const dy = pickup.y * tileSize - playerY;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                if (distance < 40) { // –†–∞–¥–∏—É—Å –ø–æ–¥–±–æ—Ä–∞
                    if (pickup.type === 'health') {
                        health = Math.min(100, health + pickup.amount);
                        showPickupEffect(`+${pickup.amount} ‚ù§Ô∏è`);
                    } else if (pickup.type === 'ammo') {
                        ammo += pickup.amount;
                        showPickupEffect(`+${pickup.amount} üî´`);
                    }
                    playPickup();
                    pickups.splice(i, 1);
                    updateHUD();
                    i--;
                }
            }
        }

        function showPickupEffect(text) {
            const effect = document.createElement('div');
            effect.className = 'pickup-effect';
            effect.textContent = text;
            effect.style.left = `${Math.random() * 60 + 20}%`;
            effect.style.top = '70%';
            document.getElementById('game-container').appendChild(effect);
            
            setTimeout(() => {
                if (effect.parentNode) {
                    effect.parentNode.removeChild(effect);
                }
            }, 1000);
        }

        function updateEnemies() {
            for (let enemy of enemies) {
                // –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –¥–æ –∏–≥—Ä–æ–∫–∞
                const dx = playerX - enemy.x * tileSize;
                const dy = playerY - enemy.y * tileSize;
                const distance = Math.sqrt(dx*dx + dy*dy);
                
                // –ï—Å–ª–∏ –∏–≥—Ä–æ–∫ —Ä—è–¥–æ–º ‚Äî –ø—Ä–µ—Å–ª–µ–¥–æ–≤–∞—Ç—å
                if (distance < 250) {
                    enemy.state = 'chase';
                } else if (distance > 350 && enemy.state === 'chase') {
                    enemy.state = 'patrol';
                }
                
                // –õ–æ–≥–∏–∫–∞ –¥–≤–∏–∂–µ–Ω–∏—è
                if (enemy.state === 'chase') {
                    // –î–≤–∏–≥–∞–µ–º—Å—è –∫ –∏–≥—Ä–æ–∫—É
                    const angle = Math.atan2(dy, dx);
                    const newX = enemy.x + Math.cos(angle) * enemy.speed * 0.05;
                    const newY = enemy.y + Math.sin(angle) * enemy.speed * 0.05;
                    
                    // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π (—É–ø—Ä–æ—â—ë–Ω–Ω–∞—è)
                    if (!checkEnemyCollision(newX, newY)) {
                        enemy.x = newX;
                        enemy.y = newY;
                    }
                    
                    // –ê—Ç–∞–∫–∞, –µ—Å–ª–∏ —Ä—è–¥–æ–º
                    if (distance < 50) {
                        health -= enemy.damage * 0.05; // –£—Ä–æ–Ω —Å–æ –≤—Ä–µ–º–µ–Ω–µ–º
                        if (health <= 0) {
                            gameOver();
                        }
                        playHurt();
                    }
                } else {
                    // –ü–∞—Ç—Ä—É–ª–∏—Ä–æ–≤–∞–Ω–∏–µ
                    const target = enemy.patrolPoints[enemy.currentIndex];
                    const dx = target.x - enemy.x;
                    const dy = target.y - enemy.y;
                    const distToTarget = Math.sqrt(dx*dx + dy*dy);
                    
                    if (distToTarget < 0.5) {
                        enemy.currentIndex = (enemy.currentIndex + 1) % enemy.patrolPoints.length;
                    } else {
                        const angle = Math.atan2(dy, dx);
                        const newX = enemy.x + Math.cos(angle) * enemy.speed * 0.05;
                        const newY = enemy.y + Math.sin(angle) * enemy.speed * 0.05;
                        
                        if (!checkEnemyCollision(newX, newY)) {
                            enemy.x = newX;
                            enemy.y = newY;
                        }
                    }
                }
            }
        }

        function checkEnemyCollision(x, y) {
            const mapX = Math.floor(x);
            const mapY = Math.floor(y);
            
            if (mapX < 0 || mapX >= mapSize || mapY < 0 || mapY >= mapSize) {
                return true;
            }
            
            return map[mapY][mapX] !== 0;
        }

        function updatePlayer() {
            if (!gameRunning) return;

            // –ü–æ–≤–æ—Ä–æ—Ç
            if (keys.ArrowLeft) playerAngle -= rotationSpeed;
            if (keys.ArrowRight) playerAngle += rotationSpeed;

            // –î–≤–∏–∂–µ–Ω–∏–µ
            let moveX = 0;
            let moveY = 0;
            let moved = false;

            if (keys.w) {
                moveX += Math.cos(playerAngle) * playerSpeed;
                moveY += Math.sin(playerAngle) * playerSpeed;
                moved = true;
            }
            if (keys.s) {
                moveX -= Math.cos(playerAngle) * playerSpeed;
                moveY -= Math.sin(playerAngle) * playerSpeed;
                moved = true;
            }
            if (keys.a) {
                moveX += Math.cos(playerAngle - Math.PI/2) * playerSpeed;
                moveY += Math.sin(playerAngle - Math.PI/2) * playerSpeed;
                moved = true;
            }
            if (keys.d) {
                moveX += Math.cos(playerAngle + Math.PI/2) * playerSpeed;
                moveY += Math.sin(playerAngle + Math.PI/2) * playerSpeed;
                moved = true;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–æ–ª–∫–Ω–æ–≤–µ–Ω–∏–π
            if (!checkCollision(playerX + moveX, playerY)) {
                playerX += moveX;
                moved = true;
            }
            if (!checkCollision(playerX, playerY + moveY)) {
                playerY += moveY;
                moved = true;
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—ã—Ö–æ–¥–∞
            if (checkExit(playerX, playerY)) {
                completeLevel();
            }

            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–æ–¥–±–æ—Ä–∞ –ø—Ä–µ–¥–º–µ—Ç–æ–≤
            checkPickups();

            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –≤—Ä–∞–≥–æ–≤
            updateEnemies();

            // –ü–æ–¥—Å—á—ë—Ç —à–∞–≥–æ–≤
            const currentTileX = Math.floor(playerX / tileSize);
            const currentTileY = Math.floor(playerY / tileSize);
            if (currentTileX !== lastPlayerTileX || currentTileY !== lastPlayerTileY) {
                totalSteps++;
                lastPlayerTileX = currentTileX;
                lastPlayerTileY = currentTileY;
                if (moved) playFootstep();
            }

            updateHUD();
        }

        function updateHUD() {
            healthEl.textContent = Math.ceil(health);
            ammoEl.textContent = ammo;
            healthEl.style.color = health > 50 ? '#fff' : health > 25 ? '#ff0' : '#f00';
        }

        function completeLevel() {
            gameRunning = false;
            stopBackgroundMusic();
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            
            finalTimeEl.textContent = `${minutes}:${seconds}`;
            finalStepsEl.textContent = totalSteps;
            completedLevelEl.textContent = currentLevel + 1;
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —Ä–µ–∫–æ—Ä–¥–æ–≤
            const levelKey = `level${currentLevel + 1}`;
            if (elapsed < records[levelKey].time) {
                records[levelKey].time = elapsed;
            }
            if (totalSteps < records[levelKey].steps) {
                records[levelKey].steps = totalSteps;
            }
            localStorage.setItem('doomLabRecords', JSON.stringify(records));
            
            // –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ä–µ–∫–æ—Ä–¥–æ–≤
            displayRecords();
            
            victoryScreen.style.display = 'flex';
            playVictory();
        }

        function displayRecords() {
            let html = '<h3>–õ—É—á—à–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã:</h3>';
            for (let i = 0; i < 3; i++) {
                const levelKey = `level${i + 1}`;
                const record = records[levelKey];
                const timeStr = record.time === Infinity ? "--:--" : 
                    `${Math.floor(record.time / 60).toString().padStart(2, '0')}:${(record.time % 60).toString().padStart(2, '0')}`;
                const stepsStr = record.steps === Infinity ? "---" : record.steps;
                html += `<div>–£—Ä–æ–≤–µ–Ω—å ${i + 1}: ${timeStr} | ${stepsStr} —à–∞–≥–æ–≤</div>`;
            }
            bestRecordsEl.innerHTML = html;
        }

        function gameOver() {
            gameRunning = false;
            stopBackgroundMusic();
            
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            
            deathTimeEl.textContent = `${minutes}:${seconds}`;
            deathStepsEl.textContent = totalSteps;
            
            gameOverScreen.style.display = 'flex';
        }

        function nextLevel() {
            currentLevel = (currentLevel + 1) % levels.length;
            victoryScreen.style.display = 'none';
            initLevel(currentLevel);
        }

        function restartGame() {
            currentLevel = 0;
            victoryScreen.style.display = 'none';
            initLevel(currentLevel);
        }

        function restartLevel() {
            initLevel(currentLevel);
        }

        function retry() {
            gameOverScreen.style.display = 'none';
            initLevel(currentLevel);
        }

        // ======================
        // –†–ï–ù–î–ï–†–ò–ù–ì
        // ======================
        function render() {
            if (!gameRunning) return;

            // –û—á–∏—Å—Ç–∫–∞ —ç–∫—Ä–∞–Ω–∞
            ctx.fillStyle = ceilingColor;
            ctx.fillRect(0, 0, canvas.width, canvas.height / 2);
            ctx.fillStyle = floorColor;
            ctx.fillRect(0, canvas.height / 2, canvas.width, canvas.height / 2);

            // Raycasting
            const fov = Math.PI / 3;
            const rayCount = canvas.width;
            const rayStep = fov / rayCount;

            for (let i = 0; i < rayCount; i++) {
                const rayAngle = playerAngle - fov / 2 + i * rayStep;
                let distance = 0;
                let hitWall = false;
                let wallSide = 'north';

                while (!hitWall && distance < mapSize * tileSize) {
                    distance += 0.5;
                    
                    const rayX = playerX + Math.cos(rayAngle) * distance;
                    const rayY = playerY + Math.sin(rayAngle) * distance;
                    
                    const mapX = Math.floor(rayX / tileSize);
                    const mapY = Math.floor(rayY / tileSize);
                    
                    if (mapX < 0 || mapX >= mapSize || mapY < 0 || mapY >= mapSize) {
                        hitWall = true;
                        distance = mapSize * tileSize;
                    } else if (map[mapY][mapX] !== 0) {
                        hitWall = true;
                        
                        const blockX = mapX * tileSize;
                        const blockY = mapY * tileSize;
                        const testPointX = (rayX - blockX) / tileSize;
                        const testPointY = (rayY - blockY) / tileSize;
                        
                        if (testPointX < 0.01) {
                            wallSide = 'west';
                        } else if (testPointX > 0.99) {
                            wallSide = 'east';
                        } else if (testPointY < 0.01) {
                            wallSide = 'north';
                        } else if (testPointY > 0.99) {
                            wallSide = 'south';
                        }
                    }
                }

                const correctedDistance = distance * Math.cos(rayAngle - playerAngle);
                const wallHeight = Math.min(5000, (tileSize / correctedDistance) * ((canvas.width / 2) / Math.tan(fov / 2)));
                
                const texture = wallTextures[wallSide];
                const texX = Math.floor((i / rayCount) * texture.width) % texture.width;
                
                const darkness = Math.min(1, correctedDistance / (tileSize * 8));
                ctx.globalAlpha = 1 - darkness * 0.7;
                
                ctx.drawImage(
                    texture,
                    texX, 0, 1, texture.height,
                    i, canvas.height / 2 - wallHeight / 2, 1, wallHeight
                );
                
                ctx.globalAlpha = 1;
            }

            renderMinimap();
            updateTimer();
        }

        function renderMinimap() {
            const cellSize = mapCanvas.width / mapSize;
            mapCtx.fillStyle = '#000';
            mapCtx.fillRect(0, 0, mapCanvas.width, mapCanvas.height);

            // –°—Ç–µ–Ω—ã, –≤—ã—Ö–æ–¥, –ø—Ä–µ–¥–º–µ—Ç—ã, –≤—Ä–∞–≥–∏
            for (let y = 0; y < mapSize; y++) {
                for (let x = 0; x < mapSize; x++) {
                    if (map[y][x] === 1) {
                        mapCtx.fillStyle = '#f00';
                        mapCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    } else if (map[y][x] === 2) {
                        mapCtx.fillStyle = '#0f0';
                        mapCtx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
                    }
                }
            }

            // –ü—Ä–µ–¥–º–µ—Ç—ã
            for (let pickup of pickups) {
                mapCtx.fillStyle = pickup.type === 'health' ? '#0f0' : '#ff0';
                mapCtx.beginPath();
                mapCtx.arc(
                    pickup.x * cellSize, 
                    pickup.y * cellSize, 
                    cellSize / 4, 0, Math.PI * 2
                );
                mapCtx.fill();
            }

            // –í—Ä–∞–≥–∏
            for (let enemy of enemies) {
                mapCtx.fillStyle = enemy.state === 'chase' ? '#f00' : '#faa';
                mapCtx.beginPath();
                mapCtx.arc(
                    enemy.x * cellSize, 
                    enemy.y * cellSize, 
                    cellSize / 3, 0, Math.PI * 2
                );
                mapCtx.fill();
            }

            // –ò–≥—Ä–æ–∫
            const playerMapX = (playerX / tileSize) * cellSize;
            const playerMapY = (playerY / tileSize) * cellSize;
            mapCtx.fillStyle = '#0f0';
            mapCtx.beginPath();
            mapCtx.arc(playerMapX, playerMapY, cellSize / 3, 0, Math.PI * 2);
            mapCtx.fill();
            mapCtx.strokeStyle = '#0f0';
            mapCtx.beginPath();
            mapCtx.moveTo(playerMapX, playerMapY);
            mapCtx.lineTo(
                playerMapX + Math.cos(playerAngle) * cellSize,
                playerMapY + Math.sin(playerAngle) * cellSize
            );
            mapCtx.stroke();
        }

        function updateTimer() {
            if (!gameRunning) return;
            const elapsed = Math.floor((Date.now() - startTime) / 1000);
            const minutes = Math.floor(elapsed / 60).toString().padStart(2, '0');
            const seconds = (elapsed % 60).toString().padStart(2, '0');
            timerEl.textContent = `${minutes}:${seconds}`;
        }

        // ======================
        // –ò–ì–†–û–í–û–ô –¶–ò–ö–õ
        // ======================
        function gameLoop() {
            updatePlayer();
            render();
            requestAnimationFrame(gameLoop);
        }

        // ======================
        // –û–ë–†–ê–ë–û–¢–ß–ò–ö–ò –ö–ù–û–ü–û–ö
        // ======================
        nextLevelBtn.addEventListener('click', nextLevel);
        restartGameBtn.addEventListener('click', restartGame);
        retryBtn.addEventListener('click', retry);

        // ======================
        // –ó–ê–ü–£–°–ö –ò–ì–†–´
        // ======================
        initLevel(currentLevel);
        gameLoop();
        displayRecords(); // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º —Ä–µ–∫–æ—Ä–¥—ã —Å—Ä–∞–∑—É
    </script>
</body>
</html>
